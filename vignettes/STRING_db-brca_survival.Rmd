---
title: "STRING DB"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
params:
  threshold: !r 700
  n.cores: !r 10
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.height = 5, fig.width = 6)
devtools::load_all()
```

## Required libraries

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(STRINGdb)
library(futile.logger)
library(parallel)
library(Matrix)
library(Vennerable)
library(survival)
library(loose.rock)
library(glmnet)
library(ggplot2)

.Last.value <- flog.layout(layout.format('[~l] ~m'))
.Last.value <- loose.rock::show.message(FALSE)
theme_set(ggplot2::theme_minimal())
```

Load this library

```{r, eval=FALSE}
library(glmSparseNet)
```

## Download Data from STRING

Retrieve all interactions

```{r}
all.interactions <- string.db.homo.sapiens(score_threshold = params$threshold)
```

## Build network matrix

Build a sparse matrix object that contains the network

```{r}
string.network <- build.string.gene.network(all.interactions$network)

string.network.undirected <- string.network + Matrix::t(string.network)
string.network.undirected <- (string.network.undirected != 0) * 1
```

## Statistics

### Graph information

```{r, echo=FALSE, collapse=TRUE}
flog.info('Directed graph (score_threshold = %d)', params$threshold)
flog.info('  *       total edges: %d', sum(string.network != 0))
flog.info('  *    unique protein: %d', nrow(string.network))
flog.info('  * edges per protein: %f', sum(string.network != 0) / nrow(string.network) )
flog.info('')
flog.info('Undirected graph (score_threshold = %d)', params$threshold)
flog.info('  *       total edges: %d', sum(string.network.undirected != 0) / 2)
flog.info('  *    unique protein: %d', nrow(string.network.undirected))
flog.info('  * edges per protein: %f', sum(string.network.undirected != 0) / 2 / nrow(string.network.undirected) )
```

### Summary of degree *(indegree + outdegree)*

```{r, echo=FALSE}
string.network.binary <- (string.network.undirected != 0) * 1

degree.network <- (Matrix::rowSums(string.network.binary) + Matrix::colSums(string.network.binary)) / 2

summary(degree.network)
```

### Histogram of degree *(up until 99.999% quantile)*

```{r, warning=FALSE}
qplot(degree.network[degree.network <= quantile(degree.network, probs = .99999)], geom = 'histogram', fill = my.colors(2), bins = 100) + theme(legend.position = 'none') + xlab('Degree (up until 99.999% quantile)')
```

And above that quantile

```{r, warning=FALSE}
qplot(degree.network[degree.network > quantile(degree.network, probs = .99999)], geom = 'histogram', fill = my.colors(2), bins = 100) + 
  theme(legend.position = 'none') +
  xlab('Degree (between 99.999% and 100% quantile)')
```

## glmSparseNet

* Build dataset that overlaps with STRING data

```{r}
xdata <- sample.BRCA.survival$xdata
ydata <- sample.BRCA.survival$ydata

#
# Add degree 0 to genes not in STRING network

degree.network.all <- colnames(xdata)[!colnames(xdata) %in% names(degree.network)] %>% {
 array(0, length(.), dimnames = list(.)) 
} %>% c(degree.network) %>% {
  .[colnames(xdata)]
}

qplot(degree.network.all, bins = 100, fill = my.colors(3)) + theme(legend.position = 'none')
```

```{r, include=FALSE}
selected.genes <- list()
```

### glmDegree model

Penalizes by the inverse of the degree `D_i* = 1 / D_i`

```{r}
cv.degree <- cv.glmDegree(xdata, 
                          Surv(ydata$time, ydata$status), 
                          family = 'cox',
                          network = degree.network.all, 
                          network.options = network.options.default(min.degree = 0.2))
```

```{r, echo=FALSE}
glmSparseNet::draw.kaplan(as.vector(coef(cv.degree, s = 'lambda.min')[,1]), xdata, ydata, plot.title = 'Full dataset', legend.outside = F)

selected.genes[['DegreeCox']] <- coef(cv.degree, s = 'lambda.min')[,1] %>% { .[. != 0] } %>%
  names %>% gene.names %>% { .[['external_gene_name']]} 
```


### glmHub model

Penalizes using the Hub heuristics, see `hub.heuristics` function definition for more details.

```{r}
cv.hub <- cv.glmHub(xdata, 
                    Surv(ydata$time, ydata$status), 
                    family = 'cox',
                    network = degree.network.all, 
                    network.options = network.options.default(min.degree = 0.2))
```

```{r, echo=FALSE}
glmSparseNet::draw.kaplan(as.vector(coef(cv.hub, s = 'lambda.min')[,1]), xdata, ydata, plot.title = 'Full dataset', legend.outside = F)

selected.genes[['Hub']] <- coef(cv.hub, s = 'lambda.min')[,1] %>% { .[. != 0] } %>%
  names %>% gene.names %>% { .[['external_gene_name']]} 
```

### glmOrphan model

Penalizes using the Orphan heuristics, see `orphan.heuristics` function definition for more details.

```{r}
cv.orphan <- cv.glmOrphan(xdata, 
                          Surv(ydata$time, ydata$status), 
                          family = 'cox',
                          network = degree.network.all, 
                          network.options = network.options.default(min.degree = 0.2))
```

```{r, echo=FALSE}
glmSparseNet::draw.kaplan(as.vector(coef(cv.orphan, s = 'lambda.min')[,1]), xdata, ydata, plot.title = 'Full dataset', legend.outside = F)

selected.genes[['Orphan']] <- coef(cv.orphan, s = 'lambda.min')[,1] %>% { .[. != 0] } %>%
  names %>% gene.names %>% { .[['external_gene_name']]} 
```

### glmnet model

Uses regular glmnet model as simple baseline

```{r}
cv.glm <- cv.glmnet(xdata, 
                    Surv(ydata$time, ydata$status), 
                    family = 'cox')
```

```{r, echo=FALSE}
glmSparseNet::draw.kaplan(as.vector(coef(cv.glm, s = 'lambda.min')[,1]), xdata, ydata, plot.title = 'Full dataset', legend.outside = F)

selected.genes[['GLMnet']] <- coef(cv.glm, s = 'lambda.min')[,1] %>% { .[. != 0] } %>%
  names %>% gene.names %>% { .[['external_gene_name']]} 
```

### Selected genes

```{r, echo=FALSE, warning=FALSE}
vv <- Vennerable::Venn(selected.genes)
Vstem <- compute.Venn(vv, type = 'squares')
PlotVennGeometry(Vstem)

melt(selected.genes) %>% apply(2, factor) %>% as.data.frame %>% ggplot() +
  geom_point(aes(value, L1), shape = my.symbols(2), color = my.colors(3), size = 3) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0)) +
  ylab('Model') + xlab('Gene')
```

