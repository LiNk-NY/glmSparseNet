---
title: "Breast survival dataset using network from STRING DB"
author: "André Veríssimo"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    number_sections: yes
    toc: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Breast survival dataset using network from STRING DB}
  %\VignetteEncoding{UTF-8}
params:
  seed: !r 2018
---

## Instalation

```{r, eval=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite('sysbiomed/glmSparseNet')
```

## Loading the packages

```{r packages, message=FALSE, warning=FALSE}
library(dplyr)
library(Matrix)
library(ggplot2)
library(parallel)
library(STRINGdb)
library(reshape2)
library(survival)
library(Vennerable)
library(loose.rock)
library(futile.logger)
library(curatedTCGAData)
#
library(glmSparseNet)
#
# Some general options for futile.logger the debugging package
.Last.value <- flog.layout(layout.format('[~l] ~m'))
.Last.value <- loose.rock::show.message(FALSE)
# Setting ggplot2 default theme as minimal
theme_set(ggplot2::theme_minimal())
```

## Overview

This vignette uses the STRING database (https://string-db.org/) of protein-protein interactions as the network-based penalizer in generalized linear models using Breast invasive carcinoma sample dataset.

The degree vector is calculated manually to account for genes that are not present in the STRING database, as these will not have any interactions, i.e. edges.

## Download Data from STRING

Retrieve all interactions from [STRING databse](https://string-db.org/). We have included a helper function that retrieves the Homo sapiens known interactions.

For this vignette, we use a cached version of all interaction with `score_threshold = 700`

*Note*: Text-based interactions are excluded from the network.

```{r, eval=FALSE}
# Not evaluated in vignette as it takes too long to download and process
all.interactions.700 <- string.db.homo.sapiens(score_threshold = 700)
```

```{r, include=FALSE}
data('all.interactions.700', package = 'glmSparseNet')
all.interactions <- all.interactions.700
```

## Build network matrix

Build a sparse matrix object that contains the network.

```{r}
string.network <- build.string.gene.network(all.interactions$network)

string.network.undirected <- string.network + Matrix::t(string.network)
string.network.undirected <- (string.network.undirected != 0) * 1
```

## Network Statistics

### Graph information

```{r, echo=FALSE, collapse=TRUE}
flog.info('Directed graph (score_threshold = %d)', 700)
flog.info('  *       total edges: %d', sum(string.network != 0))
flog.info('  *    unique protein: %d', nrow(string.network))
flog.info('  * edges per protein: %f', sum(string.network != 0) / nrow(string.network) )
flog.info('')
flog.info('Undirected graph (score_threshold = %d)', 700)
flog.info('  *       total edges: %d', sum(string.network.undirected != 0) / 2)
flog.info('  *    unique protein: %d', nrow(string.network.undirected))
flog.info('  * edges per protein: %f', sum(string.network.undirected != 0) / 2 / nrow(string.network.undirected) )
```

### Summary of degree *(indegree + outdegree)*

```{r, echo=FALSE}
string.network.binary <- (string.network.undirected != 0) * 1

degree.network <- (Matrix::rowSums(string.network.binary) + Matrix::colSums(string.network.binary)) / 2

flog.info('Summary of degree:', summary(degree.network), capture = TRUE)
```

### Histogram of degree *(up until 99.999% quantile)*

```{r, warning=FALSE}
qplot(degree.network[degree.network <= quantile(degree.network, probs = .99999)], geom = 'histogram', fill = my.colors(2), bins = 100) + theme(legend.position = 'none') + xlab('Degree (up until 99.999% quantile)')
```

And above that quantile

```{r, warning=FALSE}
qplot(degree.network[degree.network > quantile(degree.network, probs = .99999)], geom = 'histogram', fill = my.colors(2), bins = 100) + 
  theme(legend.position = 'none') +
  xlab('Degree (between 99.999% and 100% quantile)')
```

## glmSparseNet

* Dataset from curatedTCGAdata

```{r data.show, warning=FALSE, error=FALSE}
brca <- curatedTCGAData(diseaseCode = "BRCA", assays = "RNASeq2GeneNorm", FALSE)

xdata.raw <- t(assay(brca[[1]]))

# keep only primary solid tumor (code 01)
bcr_sample_barcode <- rownames(xdata.raw)[grepl('TCGA-[0-9A-Z]+-[0-9A-Z]+-01',
                                     rownames(xdata.raw))]

# Get survival information
ydata.raw <- colData(brca) %>% as.data.frame %>% 
  # Keep only data relative to survival or samples
  select(patientID, vital_status, 
         Days.to.date.of.Death, Days.to.Date.of.Last.Contact, 
         days_to_death,         days_to_last_followup,
         Vital.Status) %>% 
  # Convert days to integer
  mutate(Days.to.date.of.Death        = as.integer(Days.to.date.of.Death)) %>%
  mutate(Days.to.Date.of.Last.Contact = as.integer(Days.to.Date.of.Last.Contact)) %>%
  # Find max time between all days (ignoring missings)
  rowwise %>%
  mutate(time = max(days_to_last_followup,        Days.to.date.of.Death, 
                    Days.to.Date.of.Last.Contact, days_to_death, na.rm = T)) %>%
  # Keep only survival variables and codes
  select(patientID, status = vital_status, time) %>% 
  # Discard individuals with survival time less or equal to 0
  filter(time > 0) %>% as.data.frame

# Set index as the patientID
rownames(ydata.raw) <- ydata.raw$patientID

# Get matches between survival and assay data
common.codes <- bcr_sample_barcode[strtrim(bcr_sample_barcode, 12) %in% ydata.raw$patientID]
xdata.raw    <- xdata.raw[common.codes, ]
xdata.raw    <- xdata.raw %>% { (apply(., 2, sd) != 0) } %>% { xdata.raw[, .] } %>% scale

# Order ydata the same as assay
ydata.raw    <- ydata.raw[strtrim(rownames(xdata.raw), 12), ]

# Using only a subset of genes previously selected to keep this short example.
set.seed(params$seed)
small.subset <- c('CD5', 'CSF2RB', 'IRGC', 'NEUROG2', 'NLRC4', 'PDE11A',  
                  'PTEN', 'TP53', 'BRAF',
                  'PIK3CB', 'QARS', 'RFC3', 'RPGRIP1L', 'SDC1', 'TMEM31', 
                  'YME1L1', 'ZBTB11', sample(colnames(xdata.raw), 100)) %>% unique

xdata <- xdata.raw[, small.subset[small.subset %in% colnames(xdata.raw)]]
ydata <- ydata.raw %>% select(time, status)
```


* Build dataset that overlaps with STRING data

```{r}
#
# Add degree 0 to genes not in STRING network

degree.network.all <- colnames(xdata)[!colnames(xdata) %in% gene.names(names(degree.network))$external_gene_name] %>% {
 array(0, length(.), dimnames = list(.)) 
} %>% c(degree.network) %>% {
  .[colnames(xdata)]
}
```

Degree distribution for sample set of gene features *(in xdata)*.

```{r, echo=FALSE}
qplot(degree.network.all, bins = 100, fill = my.colors(3)) + theme(legend.position = 'none')
```


```{r, include=FALSE}
# List that will store all selected genes
selected.genes <- list()
```

### glmDegree model

Penalizes by the inverse of the degree `D_i* = 1 / D_i`

```{r}
cv.degree <- cv.glmDegree(xdata, 
                          Surv(ydata$time, ydata$status), 
                          family = 'cox',
                          network = degree.network.all, 
                          network.options = network.options.default(min.degree = 0.2))
```

Kaplan-Meier estimator separating individuals by low and high risk *(based on model's coefficients)*

```{r, echo=FALSE}
glmSparseNet::draw.kaplan(as.vector(coef(cv.degree, s = 'lambda.min')[,1]), xdata, ydata, plot.title = 'Full dataset', legend.outside = F)

selected.genes[['DegreeCox']] <- coef(cv.degree, s = 'lambda.min')[,1] %>% { .[. != 0] } %>%
  names %>% gene.names %>% { .[['external_gene_name']]} 
```


### glmHub model

Penalizes using the Hub heuristics, see `hub.heuristics` function definition for more details.

```{r}
cv.hub <- cv.glmHub(xdata, 
                    Surv(ydata$time, ydata$status), 
                    family = 'cox',
                    network = degree.network.all, 
                    network.options = network.options.default(min.degree = 0.2))
```

Kaplan-Meier estimator separating individuals by low and high risk *(based on model's coefficients)*

```{r, echo=FALSE}
glmSparseNet::draw.kaplan(as.vector(coef(cv.hub, s = 'lambda.min')[,1]), xdata, ydata, plot.title = 'Full dataset', legend.outside = F)

selected.genes[['Hub']] <- coef(cv.hub, s = 'lambda.min')[,1] %>% { .[. != 0] } %>%
  names %>% gene.names %>% { .[['external_gene_name']]} 
```

### glmOrphan model

Penalizes using the Orphan heuristics, see `orphan.heuristics` function definition for more details.

```{r}
cv.orphan <- cv.glmOrphan(xdata, 
                          Surv(ydata$time, ydata$status), 
                          family = 'cox',
                          network = degree.network.all, 
                          network.options = network.options.default(min.degree = 0.2))
```

Kaplan-Meier estimator separating individuals by low and high risk *(based on model's coefficients)*

```{r, echo=FALSE}
glmSparseNet::draw.kaplan(as.vector(coef(cv.orphan, s = 'lambda.min')[,1]), xdata, ydata, plot.title = 'Full dataset', legend.outside = F)

selected.genes[['Orphan']] <- coef(cv.orphan, s = 'lambda.min')[,1] %>% { .[. != 0] } %>%
  names %>% gene.names %>% { .[['external_gene_name']]} 
```

### glmnet model

Uses regular glmnet model as simple baseline

```{r}
cv.glm <- cv.glmnet(xdata, 
                    Surv(ydata$time, ydata$status), 
                    family = 'cox')
```

Kaplan-Meier estimator separating individuals by low and high risk *(based on model's coefficients)*

```{r, echo=FALSE}
glmSparseNet::draw.kaplan(as.vector(coef(cv.glm, s = 'lambda.min')[,1]), xdata, ydata, plot.title = 'Full dataset', legend.outside = F)

selected.genes[['GLMnet']] <- coef(cv.glm, s = 'lambda.min')[,1] %>% { .[. != 0] } %>%
  names %>% gene.names %>% { .[['external_gene_name']]} 
```

### Selected genes

Venn diagram of overlapping genes.

```{r, echo=FALSE, warning=FALSE}
vv <- Venn(selected.genes)
Vstem <- compute.Venn(vv, type = 'squares')
PlotVennGeometry(Vstem)
```

Descriptive table showing which genes are selected in each model

```{r, echo=FALSE}
melt(selected.genes) %>% apply(2, factor) %>% as.data.frame %>% ggplot() +
  geom_point(aes(value, L1), shape = my.symbols(2), color = my.colors(3), size = 3) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0)) +
  ylab('Model') + xlab('Gene')
```


